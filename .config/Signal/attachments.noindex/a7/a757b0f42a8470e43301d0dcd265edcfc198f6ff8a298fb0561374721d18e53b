clear all;

% setting sampling params %
sampling_freq = 25000;
N_aq = 1000;
range = 2;
reps = 4;

spectrum_n_all = 0;
rms_all = 0;

for i=1:reps

    % getting data from our DAQ %
    daq_storage = daq("ni");
    daq_storage.Rate = sampling_freq;

    ch = addinput(daq_storage,"Dev2","ai0","Voltage");
    ch.Range = [-range, range];

    samples = read(daq_storage, N_aq, "OutputFormat", "Matrix");


    % fft of samples %
    spectrum = fft(samples);
    spectrum = fftshift(spectrum);


    % frequency vector %
    freq_res = sampling_freq / N_aq;
    freq_vec = 0 : length(spectrum)/2 - 1;
    freq_vec = freq_vec * freq_res;


    % using half of the spectrum %
    spectrum = abs(spectrum(length(spectrum)/2 +1 : end));


    % normalized vector %
    spectrum_n = spectrum / N_aq * 2;
    spectrum_n(1) = spectrum(1) / N_aq;

    % rms %
    sum = 0;

    for i = 1 : N_aq
        sum = sum + samples(i) * samples(i);
    end

    rms = sqrt(sum / N_rounded);

    spectrum_n_all = spectrum_n_all + spectrum_n;
    rms_all = rms_all + rms;

end

spectrum_n = sum(spectrum_n_all) / reps;
rms = sum(rms_all) / reps;


% estimating frequency %
[peak, peak_idx] = max(spectrum_n);

neighbor_idx = 0;

if (peak_idx -1 <= 0)
    L = peak_idx;
    neighbor_idx = peak_idx +1;

elseif (spectrum_n(peakidx -1) > spectrum_n(peakidx +1)) % Find suitable neighbor to use in ipDFT formula %
	neighbor_idx = peak_idx -1;
	L = neighbor_idx;

else
	L = peak_idx;
   	neighbor_idx = peak_idx +1;
end


% calculating ipDFT for frequency estimation %
Upk = real(spectrum_n(L));
Une = real(spectrum_n(L+1));
Vpk = imag(spectrum_n(L));
Vne = imag(spectrum_n(L+1));

n = 2*pi / N_aq; % radians per acquisition %

Vr = Vne - Vpk;
Ur = Une - Upk;

peak_rad     = n * peak_idx;
neighbor_rad = n * neighbor_idx;

Kopt = (Vr * sin(peak_rad) + Ur * cos(peak_rad)) / Ur;

Zpk = Vpk * (Kopt - cos(peak_rad)     / sin(peak_rad)) + Upk;
Zne = Vne * (Kopt - cos(neighbor_rad) / sin(neighbor_rad)) + Une;

Zr = Zne - Zpk;

lambda = acos((Zne * cos(neighbor_rad) - Zpk * cos(peak_rad)) / Zr) / n -1;
est_freq = lambda * freq_res;


% power %
power = spectrum_n / sqrt(2);
power = power(1:end).^2;

power_db = 10 * log10(power);


% mean value %
s_p  = sampling_freq / est_freq; % samples per period %
N_cp  = floor(N_aq / s_p);       % number of completed periods %

N_rounded = round(N_cp * s_p);

sum = 0;

for i = 1:N_rounded
    sum = sum + samples(i);
end

avg_volts = sum / N_rounded;


% harmonics %
N_h = 11; 

h_freq_idx = 1 : N_h;
h_freq_idx = (h_freq_idx) * (peak_idx -1);
h_freq = h_freq_idx * freq_res;

for i = 1 : N_h
    h_volt(i) = spectrum_n(h_freq_idx(i));
end

h_volt_rms = h_volt / sqrt(2);


% thd %
sum = 0;
for i = 2 : N_h
  sum  = sum + h_volt_rms(i) * h_volt_rms(i);
end

thd = sqrt(sum) / h_volt(1);
thd_dB = 20 * log10(thd);


% effective noise %
EN = 20*log10(sqrt(sum(power)));


% powers %
idx = round(est_freq / sampling_freq * N_rounded) +1;
fundamentalPowerAmp = power(idx);
fundamentalPower1 = 10*log10(fundamentalPowerAmp);
fundamentalPower2 = 10*log10(range);

if (fundamentalPower1 > fundamentalPower2)
    fundamentalPower = fundamentalPower1;
else
    fundamentalPower = fundamentalPower2;
end


% Potência de ruído
power_mean_db = 10*log10(sum(power)/N_rounded);


% sinad & enob %
sinad = abs(fundamentalPower - power_mean_db);
enob = (sinad-1.76)/6.02;


% plot %
subplot(2, 1, 1);

plot((0:N_aq-1) / sampling_freq, samples);
xlim([0 N_aq/sampling_freq]); 
xlabel('Sampler \Delta time / s');
ylabel('Sampled signal amplitude / V');
title(sprintf('Sampled signal\n Estimated original signal frequency: %f Hz\n Average value: %f  RMS: %f\n Number of acquisitions: %d Sampler Frequency:%f\n Range:[%d,%d]', est_freq, avg,rms,N_aq, sampling_freq, -range, range));

subplot(2,1,2);

spectral_resol = sampling_freq / N_aq;

power_vec = 2 * abs(spectrum_n) / sqrt(2);
x2 = 0 : spectral_resol : spectral_resol * (N_aq/2 -1);
plot(x2, 20*log10(power_vec(1 : N_aq/2) / N_aq), '.-'); % log scale %

xlabel('Frequency / Hz');
ylabel('Logarithmic power / dBV^2');
title(sprintf('Single-sided Logarithmic signal power'));

%{
subplot(2,1,1);
plot(freq_vec, power_db);

subplot(2,1,2);
scatter(h_freq, h_volt);
%}
